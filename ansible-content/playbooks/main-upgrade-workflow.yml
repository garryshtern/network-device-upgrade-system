---
# Network Device Upgrade Management System - Master Workflow
# Complete upgrade orchestration with phase separation and validation
#
# This playbook orchestrates the entire upgrade process across
# supported platforms:
# - Phase 1: Image Loading (Business Hours Safe)
# - Phase 2: Image Installation (Maintenance Window)
# - Comprehensive validation and rollback capabilities

- name: Network Device Upgrade - Master Workflow
  hosts: "{{ target_hosts | default('all') }}"
  gather_facts: false
  serial: "{{ max_concurrent | default(5) }}"
  vars:
    # Connection override for unsupported network OS in check mode
    ansible_connection: "{{ 'local' if (ansible_check_mode | default(false) and ansible_network_os | default('') in ['metamako.mos', 'mos']) else omit }}"
    # Workflow control variables
    # Options: full, loading, installation, validation, rollback
    upgrade_phase: "{{ phase | default('full') }}"
    # Firmware selection - supports both global and platform-specific targeting
    firmware_version: "{{ target_firmware }}"
    platform_specific_firmware: "{{ platform_firmware | default({}) }}"
    maintenance_window: "{{ maintenance | default(false) | bool }}"
    skip_validation: "{{ skip_checks | default(false) | bool }}"
    rollback_on_failure: "{{ auto_rollback | default(true) | bool }}"
    # Security configuration - prioritize SSH keys over passwords
    ansible_ssh_private_key_file: "{{ ssh_key_file | default(omit) }}"
    ansible_ssh_pass: "{{ ssh_password | default(omit) }}"
    # Device grouping and concurrency
    batch_id: "{{ ansible_play_batch | hash('md5') }}"
    operator_id: "{{ lookup('env', 'USER') | default('ansible') }}"
    # Timing and retry settings
    max_retry_attempts: 3
    connectivity_timeout: 300
    reboot_wait_time: 600
    # Validation settings
    pre_check_required: true
    post_check_required: true
    network_state_comparison: true
    # Paths and storage
    firmware_base_path: "/var/lib/network-upgrade/firmware"
    backup_base_path: "/var/lib/network-upgrade/backups"
    # Task paths for shorter include_tasks references
    common: "../roles/common/tasks"
    validate: "../roles/image-validation/tasks"
    space: "../roles/space-management/tasks"
  pre_tasks:
    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - target_firmware is defined or platform_specific_firmware != {}
          - target_hosts is defined
        fail_msg: >
          Required variables missing: Either target_firmware (global) or
          platform_specific_firmware (per-platform) must be defined,
          and target_hosts must be defined

    - name: Resolve platform-specific firmware version
      ansible.builtin.set_fact:
        resolved_firmware_version: >-
          {% if platform_specific_firmware != {} %}
            {%- set platform_key = platform_type |
                default(ansible_network_os) -%}
            {%- set device_model_key = device_model | default('default') -%}
            {%- if platform_key in platform_specific_firmware -%}
              {%- if device_model_key in
                  platform_specific_firmware[platform_key] -%}
                {{ platform_specific_firmware[platform_key][device_model_key] }}
              {%- elif 'default' in platform_specific_firmware[platform_key] -%}
                {{ platform_specific_firmware[platform_key]['default'] }}
              {%- else -%}
                {{ target_firmware | default('') }}
              {%- endif -%}
            {%- else -%}
              {{ target_firmware | default('') }}
            {%- endif -%}
          {%- else -%}
            {{ target_firmware | default('') }}
          {%- endif -%}
      when: platform_specific_firmware != {} or target_firmware is defined

    - name: Set final firmware version for workflow
      ansible.builtin.set_fact:
        firmware_version: >
          {{ resolved_firmware_version | default(target_firmware) }}
        target_firmware_version: >-
          {{ resolved_firmware_version | default(target_firmware) }}

    - name: Set upgrade start timestamp
      ansible.builtin.set_fact:
        upgrade_start_time: >-
          {{ lookup('pipe', 'date -u +%Y-%m-%dT%H:%M:%SZ') }}
        upgrade_job_id: >-
          {{ inventory_hostname }}_{{ ansible_play_batch | hash('md5') }}

    - name: Display upgrade parameters
      ansible.builtin.debug:
        msg:
          - "=== Network Device Upgrade Workflow ==="
          - "Target Device: {{ inventory_hostname }}"
          - "Current Platform: {{ ansible_network_os | default('unknown') }}"
          - "Target Firmware: {{ firmware_version }}"
          - "Upgrade Phase: {{ upgrade_phase }}"
          - "Maintenance Window: {{ maintenance_window }}"
          - "Batch ID: {{ batch_id }}"
          - "Job ID: {{ upgrade_job_id }}"
          - "======================================="

  tasks:
    # Phase 0: Pre-Upgrade Validation and Preparation
    - name: Phase 0 - Pre-Upgrade Validation
      block:
        - name: Device connectivity check
          ansible.builtin.include_tasks: "{{ common }}/connectivity-check.yml"

        - name: Device health check and baseline capture
          ansible.builtin.include_tasks: "{{ common }}/health-check.yml"
          when: not skip_validation

        - name: Verify firmware availability
          ansible.builtin.include_tasks: "{{ validate }}/integrity-audit.yml"

        - name: Check storage space
          ansible.builtin.include_tasks: "{{ space }}/space-check.yml"

      rescue:
        - name: Pre-validation failure handling
          ansible.builtin.include_tasks: "{{ common }}/error-handling.yml"
          vars:
            error_phase: "pre_validation"
            error_message: "Pre-upgrade validation failed"

    # Phase 1: Image Loading (Business Hours Safe)
    - name: Phase 1 - Image Loading
      block:
        - name: Storage cleanup
          ansible.builtin.include_tasks: "{{ common }}/storage-cleanup.yml"
          when: upgrade_phase in ['full', 'loading']

        - name: Backup current configuration
          ansible.builtin.include_tasks: ../roles/common/tasks/config-backup.yml
          when: upgrade_phase in ['full', 'loading']

        - name: Load firmware image
          ansible.builtin.include_tasks: ../roles/common/tasks/image-loading.yml
          when: upgrade_phase in ['full', 'loading']

        - name: Verify loaded image integrity
          ansible.builtin.include_tasks:
            ../roles/image-validation/tasks/hash-verification.yml
          when: upgrade_phase in ['full', 'loading']

      rescue:
        - name: Image loading failure handling
          ansible.builtin.include_tasks: "{{ common }}/error-handling.yml"
          vars:
            error_phase: "image_loading"
            error_message: "Image loading phase failed"

    # Phase 2: Image Installation (Maintenance Window Only)
    - name: Phase 2 - Image Installation
      block:
        - name: Maintenance window validation
          ansible.builtin.assert:
            that:
              - maintenance_window | bool
            fail_msg: "Image installation requires maintenance_window=true"
          when:
            - upgrade_phase in ['full', 'installation']
            - not ansible_check_mode

        - name: Final pre-installation checks
          ansible.builtin.include_tasks:
            ../roles/network-validation/tasks/protocol-convergence.yml
          when: >
            upgrade_phase in ['full', 'installation'] and not skip_validation
            and ansible_network_os in ['cisco.nxos.nxos', 'cisco.ios.ios', 'arista.eos.eos']

        - name: Install firmware image
          ansible.builtin.include_tasks: image-installation.yml
          when: upgrade_phase in ['full', 'installation']

      rescue:
        - name: Installation failure - trigger rollback
          ansible.builtin.include_tasks: "{{ common }}/emergency-rollback.yml"
          when: rollback_on_failure | bool

    # Phase 3: Post-Installation Validation
    - name: Phase 3 - Post-Installation Validation
      block:
        - name: Wait for device recovery
          ansible.builtin.wait_for_connection:
            timeout: "{{ connectivity_timeout }}"
            delay: 30
          when: upgrade_phase in ['full', 'installation', 'validation']

        - name: Post-upgrade network validation
          ansible.builtin.include_role:
            name: network-validation
          when: >
            upgrade_phase in ['full', 'installation', 'validation']
            and not skip_validation
            and ansible_network_os in ['cisco.nxos.nxos', 'cisco.ios.ios', 'arista.eos.eos']

        - name: Update device inventory
          ansible.builtin.include_tasks: "{{ common }}/metrics-export.yml"
          vars:
            metric_type: "upgrade_completion"
            upgrade_status: "success"

        - name: Compliance audit update
          ansible.builtin.include_tasks: "{{ common }}/compliance-audit.yml"
          when: upgrade_phase in ['full', 'validation']

      rescue:
        - name: Post-validation failure - trigger rollback
          ansible.builtin.include_tasks: "{{ common }}/emergency-rollback.yml"
          when: rollback_on_failure | bool and upgrade_phase != 'validation'

    # Rollback workflow (when explicitly requested)
    - name: Rollback Workflow
      block:
        - name: Execute emergency rollback
          ansible.builtin.include_tasks: "{{ common }}/emergency-rollback.yml"
          when: upgrade_phase == 'rollback'

      rescue:
        - name: Rollback failure handling
          ansible.builtin.include_tasks: "{{ common }}/error-handling.yml"
          vars:
            error_phase: "rollback"
            error_message: >
              Rollback procedure failed - manual intervention required

  post_tasks:
    - name: Set upgrade completion timestamp
      ansible.builtin.set_fact:
        upgrade_end_time: "{{ lookup('pipe', 'date -u +%Y-%m-%dT%H:%M:%SZ') | trim }}"

    - name: Calculate upgrade duration
      ansible.builtin.set_fact:
        upgrade_duration: >
          {{
            ((upgrade_end_time | to_datetime('%Y-%m-%dT%H:%M:%SZ')) -
            (upgrade_start_time |
            to_datetime('%Y-%m-%dT%H:%M:%SZ'))).total_seconds()
          }}

    - name: Export final metrics
      ansible.builtin.include_tasks: "{{ common }}/metrics-export.yml"
      vars:
        metric_type: "upgrade_summary"
        duration_seconds: "{{ upgrade_duration }}"
        final_status: >
          {{ 'success' if ansible_failed_result is not defined else 'failed' }}

    - name: Display upgrade summary
      ansible.builtin.debug:
        msg:
          - "=== Upgrade Summary ==="
          - "Device: {{ inventory_hostname }}"
          - "Job ID: {{ upgrade_job_id }}"
          - "Duration: {{ upgrade_duration }}s"
          - >
            Status: {{
              'SUCCESS' if ansible_failed_result is not defined else 'FAILED'
            }}
          - "Start: {{ upgrade_start_time }}"
          - "End: {{ upgrade_end_time }}"
          - "======================="

  handlers:
    - name: Emergency cleanup
      ansible.builtin.include_tasks: "{{ common }}/error-handling.yml"
      vars:
        cleanup_required: true
