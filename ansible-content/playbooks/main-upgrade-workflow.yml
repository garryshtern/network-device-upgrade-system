---
# Network Device Upgrade Management System - Master Workflow
# REDESIGNED: Proper workflow sequence with fail-fast validation
#
# Workflow Steps:
# 1. Check connectivity (basic platform-specific commands)
# 2. Check space (cleanup if needed, then recheck)
# 3. Upload images (server-initiated PUSH only)
# 4. Run pre-checks (BGP/OSPF/interfaces - must pass to continue)
# 5. Install images and reboot
# 6. Run post-checks & compare (failure triggers optional rollback)
#
# CRITICAL: Steps 1-5 must pass or workflow STOPS
# Step 6 failure triggers optional rollback only

- name: Network Device Upgrade - Master Workflow
  hosts: "{{ target_hosts | default('all') }}"
  gather_facts: false
  serial: "{{ max_concurrent | default(5) }}"
  vars:
    # Firmware configuration
    firmware_version: "{{ target_firmware }}"
    platform_specific_firmware: "{{ platform_firmware | default({}) }}"

    # Workflow control
    maintenance_window: "{{ maintenance | default(false) | bool }}"
    rollback_on_failure: "{{ auto_rollback | default(true) | bool }}"

    # Security - SSH keys preferred over passwords
    ansible_ssh_private_key_file: "{{ ssh_key_file | default(omit) }}"
    ansible_ssh_pass: "{{ ssh_password | default(omit) }}"

    # Batch tracking
    batch_id: "{{ ansible_play_batch | hash('md5') }}"
    operator_id: "{{ lookup('env', 'USER') | default('ansible') }}"

    # Timeouts and retries
    connectivity_timeout: 300
    reboot_wait_time: 600
    max_retry_attempts: 3

    # Paths
    firmware_base_path: "/var/lib/network-upgrade/firmware"
    backup_base_path: "/var/lib/network-upgrade/backups"
    baseline_base_path: "/var/lib/network-upgrade/baselines"

    # Task paths
    common: "../roles/common/tasks"
    validate: "../roles/image-validation/tasks"
    space: "../roles/space-management/tasks"
    network: "../roles/network-validation/tasks"

  pre_tasks:
    - name: Override connection for Metamako in check mode
      ansible.builtin.set_fact:
        ansible_connection: local
      when:
        - ansible_check_mode is defined
        - ansible_check_mode
        - platform_type is defined
        - platform_type == 'metamako_mos'

    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - target_firmware is defined or platform_specific_firmware != {}
          - target_hosts is defined
        fail_msg: >
          Required variables missing. Either target_firmware or
          platform_specific_firmware must be defined.

    - name: Resolve platform-specific firmware version
      ansible.builtin.set_fact:
        resolved_firmware_version: >-
          {% if platform_specific_firmware != {} %}
            {%- set platform_key = platform_type | default('unknown') -%}
            {%- set device_model_key = device_model | default('default') -%}
            {%- if platform_key in platform_specific_firmware -%}
              {%- if device_model_key in platform_specific_firmware[platform_key] -%}
                {{ platform_specific_firmware[platform_key][device_model_key] }}
              {%- elif 'default' in platform_specific_firmware[platform_key] -%}
                {{ platform_specific_firmware[platform_key]['default'] }}
              {%- else -%}
                {{ target_firmware | default('') }}
              {%- endif -%}
            {%- else -%}
              {{ target_firmware | default('') }}
            {%- endif -%}
          {%- else -%}
            {{ target_firmware | default('') }}
          {%- endif -%}

    - name: Set final firmware version for workflow
      ansible.builtin.set_fact:
        firmware_version: "{{ resolved_firmware_version | default(target_firmware) }}"
        target_firmware_version: "{{ resolved_firmware_version | default(target_firmware) }}"

    - name: Set upgrade start timestamp
      ansible.builtin.set_fact:
        upgrade_start_time: "{{ lookup('pipe', 'date -u +%Y-%m-%dT%H:%M:%SZ') }}"
        upgrade_job_id: "{{ inventory_hostname }}_{{ ansible_play_batch | hash('md5') }}"

    - name: Validate maintenance window requirement
      ansible.builtin.assert:
        that:
          - maintenance_window | bool
        fail_msg: "Firmware upgrades require maintenance_window=true"
      when: not ansible_check_mode

    - name: Display upgrade parameters
      ansible.builtin.debug:
        msg:
          - "=== Network Device Upgrade Workflow ==="
          - "Target Device: {{ inventory_hostname }}"
          - "Platform Type: {{ platform_type | default('unknown') }}"
          - "Network OS: {{ ansible_network_os | default('N/A') }}"
          - "Target Firmware: {{ firmware_version }}"
          - "Maintenance Window: {{ maintenance_window }}"
          - "Batch ID: {{ batch_id }}"
          - "Job ID: {{ upgrade_job_id }}"
          - "======================================="

  tasks:
    # STEP 1: Check Connectivity
    # Uses platform-specific commands (not generic "show version")
    # MUST PASS or workflow STOPS
    - name: "STEP 1: Connectivity Check"
      block:
        - name: Platform-specific connectivity validation
          ansible.builtin.include_tasks: "{{ common }}/connectivity-check.yml"

      rescue:
        - name: Connectivity check failed - STOP workflow
          ansible.builtin.fail:
            msg: "STEP 1 FAILED: Connectivity check failed. Workflow stopped."

    # STEP 2: Check Space (Cleanup if Needed)
    # Only runs cleanup if insufficient space detected
    # MUST PASS or workflow STOPS
    - name: "STEP 2: Storage Space Validation"
      block:
        - name: Check available storage space
          ansible.builtin.include_tasks: "{{ space }}/space-check.yml"

        - name: Conditional cleanup if insufficient space
          ansible.builtin.include_tasks: "{{ common }}/storage-cleanup.yml"
          when:
            - storage_info is defined
            - storage_info.free_space_gb < (required_space_gb | default(4))

        - name: Recheck space after cleanup
          ansible.builtin.include_tasks: "{{ space }}/space-check.yml"
          when:
            - storage_info is defined
            - storage_info.free_space_gb < (required_space_gb | default(4))

        - name: Verify sufficient space available
          ansible.builtin.assert:
            that:
              - storage_info is defined
              - storage_info.free_space_gb >= (required_space_gb | default(4))
            fail_msg: >
              Insufficient storage space. Available: {{ storage_info.free_space_gb }}GB,
              Required: {{ required_space_gb | default(4) }}GB

      rescue:
        - name: Storage validation failed - STOP workflow
          ansible.builtin.fail:
            msg: "STEP 2 FAILED: Storage space validation failed. Workflow stopped."

    # STEP 3: Upload Images
    # Server-initiated PUSH only (no device-initiated pulls)
    # MUST PASS or workflow STOPS
    - name: "STEP 3: Image Upload"
      block:
        - name: Verify firmware image availability
          ansible.builtin.include_tasks: "{{ validate }}/integrity-audit.yml"

        - name: Backup current configuration
          ansible.builtin.include_tasks: "{{ common }}/config-backup.yml"

        - name: Upload firmware image to device
          ansible.builtin.include_tasks: "{{ common }}/image-loading.yml"

        - name: Verify uploaded image integrity
          ansible.builtin.include_tasks: "{{ validate }}/hash-verification.yml"

      rescue:
        - name: Image upload failed - STOP workflow
          ansible.builtin.fail:
            msg: "STEP 3 FAILED: Image upload failed. Workflow stopped."

    # STEP 4: Run Pre-Checks
    # Comprehensive validation: BGP, OSPF, interfaces
    # Optional protocols handled conditionally
    # MUST PASS or workflow STOPS
    - name: "STEP 4: Pre-Upgrade Validation"
      block:
        - name: Capture pre-upgrade network state
          ansible.builtin.include_role:
            name: network-validation
          vars:
            validation_phase: "pre_upgrade"
            save_baseline: true

        - name: Verify all critical services are operational
          ansible.builtin.assert:
            that:
              - network_validation_results is defined
              - network_validation_results.overall_status == "healthy"
            fail_msg: "Pre-upgrade validation failed. Network not in healthy state."

      rescue:
        - name: Pre-upgrade validation failed - STOP workflow
          ansible.builtin.fail:
            msg: "STEP 4 FAILED: Pre-upgrade validation failed. Workflow stopped."

    # STEP 5: Install Images and Reboot
    # Platform-specific installation
    # MUST PASS or workflow STOPS
    - name: "STEP 5: Firmware Installation"
      block:
        - name: Install firmware - Cisco NX-OS
          ansible.builtin.include_role:
            name: cisco-nxos-upgrade
            tasks_from: image-installation
          when:
            - ansible_network_os is defined
            - ansible_network_os == 'cisco.nxos.nxos'

        - name: Install firmware - Cisco IOS-XE
          ansible.builtin.include_role:
            name: cisco-iosxe-upgrade
            tasks_from: image-installation
          when:
            - ansible_network_os is defined
            - ansible_network_os == 'cisco.ios.ios'

        - name: Install firmware - FortiOS
          ansible.builtin.include_role:
            name: fortios-upgrade
            tasks_from: image-installation
          when:
            - ansible_network_os is defined
            - ansible_network_os == 'fortinet.fortios.fortios'

        - name: Install firmware - Metamako MOS
          ansible.builtin.include_role:
            name: metamako-mos-upgrade
            tasks_from: image-installation
          when:
            - platform_type is defined
            - platform_type == 'metamako_mos'

        - name: Install firmware - Opengear
          ansible.builtin.include_role:
            name: opengear-upgrade
            tasks_from: image-installation
          when:
            - platform_type is defined
            - platform_type == 'opengear'

        - name: Wait for device to come back online
          ansible.builtin.wait_for_connection:
            timeout: "{{ connectivity_timeout }}"
            delay: 30

      rescue:
        - name: Installation failed - STOP workflow
          ansible.builtin.fail:
            msg: "STEP 5 FAILED: Installation failed. Workflow stopped."

    # STEP 6: Post-Checks and Comparison
    # Compare to pre-upgrade state
    # Failure triggers OPTIONAL rollback (does not stop workflow)
    - name: "STEP 6: Post-Upgrade Validation"
      block:
        - name: Capture post-upgrade network state
          ansible.builtin.include_role:
            name: network-validation
          vars:
            validation_phase: "post_upgrade"
            compare_to_baseline: true

        - name: Compare pre/post upgrade states
          ansible.builtin.assert:
            that:
              - network_validation_results is defined
              - network_validation_results.comparison_status == "passed"
            fail_msg: "Post-upgrade validation shows degradation from baseline."

      rescue:
        - name: Post-validation failed - trigger optional rollback
          block:
            - name: Execute rollback procedure
              ansible.builtin.include_tasks: "{{ common }}/emergency-rollback.yml"
              when: rollback_on_failure | bool

            - name: Log post-validation failure
              ansible.builtin.debug:
                msg: >
                  WARNING: Post-upgrade validation failed.
                  Rollback {{ 'executed' if rollback_on_failure else 'skipped (disabled)' }}.

          always:
            - name: Mark upgrade with validation warnings
              ansible.builtin.set_fact:
                upgrade_completed_with_warnings: true

  post_tasks:
    - name: Set upgrade completion timestamp
      ansible.builtin.set_fact:
        upgrade_end_time: "{{ lookup('pipe', 'date -u +%Y-%m-%dT%H:%M:%SZ') }}"

    - name: Calculate upgrade duration
      ansible.builtin.set_fact:
        upgrade_duration: >
          {{
            ((upgrade_end_time | to_datetime('%Y-%m-%dT%H:%M:%SZ')) -
            (upgrade_start_time | to_datetime('%Y-%m-%dT%H:%M:%SZ'))).total_seconds()
          }}

    - name: Export final metrics
      ansible.builtin.include_tasks: "{{ common }}/metrics-export.yml"
      vars:
        metric_type: "upgrade_summary"
        duration_seconds: "{{ upgrade_duration }}"
        final_status: >
          {{
            'success' if ansible_failed_result is not defined
            else ('warning' if upgrade_completed_with_warnings is defined else 'failed')
          }}

    - name: Display upgrade summary
      ansible.builtin.debug:
        msg:
          - "=== Upgrade Summary ==="
          - "Device: {{ inventory_hostname }}"
          - "Job ID: {{ upgrade_job_id }}"
          - "Duration: {{ upgrade_duration }}s"
          - >
            Status: {{
              'SUCCESS' if ansible_failed_result is not defined
              else ('WARNING' if upgrade_completed_with_warnings is defined else 'FAILED')
            }}
          - "Start: {{ upgrade_start_time }}"
          - "End: {{ upgrade_end_time }}"
          - "======================="
