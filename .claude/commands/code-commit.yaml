name: code-commit
description: Carefully review, validate, and commit code changes following strict contribution guidelines
version: "1.0.0"

input:
  - name: commit_message
    description: Commit message describing the changes
    required: true
  - name: files
    description: Specific files to commit (defaults to all staged changes)
    required: false
  - name: push
    description: Whether to push after committing
    required: false
    default: true
  - name: branch
    description: Target branch for the commit
    required: false
  - name: force_checks
    description: Force all validation checks even if they pass initially
    required: false
    default: false
  - name: skip_tests
    description: Skip running tests (not recommended)
    required: false
    default: false

output:
  - type: validation_report
    description: Detailed validation and compliance report
  - type: test_results
    description: Test execution results and coverage report
  - type: commit_info
    description: Git commit and push details
  - type: recommendations
    description: Suggestions for future improvements

prompt: |
  I need you to carefully validate and commit code changes following strict contribution guidelines. Please execute this comprehensive process:

  ## 1. Pre-Commit Validation

  **Git Status Analysis:**
  - Check current branch and working directory state
  - Review staged vs unstaged changes
  - Verify no conflicts or unresolved merges
  - Ensure we're on the correct branch: {{branch or "current branch"}}
  - Identify all files that will be committed

  **File Scope Determination:**
  {% if files %}
  - Focus on specified files: {{files}}
  - Validate these files exist and are staged
  {% else %}
  - Review all staged changes
  - Ensure no unintended files are included
  {% endif %}

  ## 2. Code Quality Validation

  **PEP 8 Compliance (Python files):**
  - Run flake8 for style guide enforcement
  - Execute black for code formatting validation
  - Check with pycodestyle for additional PEP 8 violations
  - Verify import organization with isort
  - Ensure docstring compliance with pydocstyle

  **Type Hints Verification:**
  - Scan all new/modified Python functions and methods
  - Verify type hints are present and correct
  - Run mypy for static type checking
  - Ensure return types are properly annotated

  **Code Style Consistency:**
  - Check adherence to existing code patterns
  - Verify naming conventions match project standards
  - Ensure consistent indentation and formatting
  - Validate comment and docstring quality

  **Dependency Management:**
  - Check if new dependencies were added
  - Verify dependencies are up to date and secure
  - Ensure requirements.txt/pyproject.toml is updated
  - Check for any deprecated or vulnerable packages

  ## 3. Comprehensive Testing

  {% if not skip_tests %}
  **Unit Test Execution:**
  - Run all existing unit tests to ensure no regressions
  - Execute tests for new/modified code specifically
  - Verify all tests pass without warnings
  - Check test execution time for performance regressions

  **Test Coverage Analysis:**
  - Generate coverage report for new/modified code
  - Ensure 100% test coverage for new functionality
  - Identify any uncovered lines or branches
  - Verify existing coverage is maintained or improved

  **New Feature Test Requirements:**
  - Verify unit tests exist for all new features
  - Check that edge cases are covered
  - Ensure error handling is tested
  - Validate integration tests if applicable
  {% endif %}

  ## 4. Documentation Validation

  **Code Documentation:**
  - Verify all new functions have proper docstrings
  - Check that docstrings follow project format (Google/NumPy/Sphinx style)
  - Ensure complex logic is commented appropriately
  - Validate API documentation is updated

  **Project Documentation:**
  - Check if README.md needs updates
  - Verify changelog/release notes if applicable
  - Ensure any new features are documented
  - Update API documentation if needed

  ## 5. Commit Message Validation

  **Message Structure Analysis:**
  - Commit message: "{{commit_message}}"
  - Verify follows conventional commit format if required
  - Check message is meaningful and descriptive
  - Ensure message accurately describes the changes
  - Validate length and formatting standards

  **Content Validation:**
  - Confirm message describes what and why, not just what
  - Check for appropriate scope/type (feat, fix, docs, etc.)
  - Ensure message follows project conventions
  - Verify breaking changes are noted if applicable

  ## 6. Change Size and Structure Analysis

  **Change Complexity Assessment:**
  - Analyze the scope and size of changes
  - Identify if changes are monolithic and should be split
  - Check if multiple unrelated changes are bundled
  - Suggest breaking into smaller commits if needed

  **Branch Strategy Compliance:**
  - Verify we're committing to appropriate branch
  - Check if feature/bug fix should be on separate branch
  - Ensure branch naming follows project conventions
  - Validate merge strategy compatibility

  ## 7. Security and Best Practices

  **Security Scan:**
  - Check for potential security vulnerabilities
  - Ensure no secrets or sensitive data are committed
  - Validate input sanitization in new code
  - Check for SQL injection or XSS vulnerabilities

  **Best Practices Verification:**
  - Ensure error handling is appropriate
  - Validate logging and monitoring considerations
  - Check for proper resource cleanup
  - Verify thread safety where applicable

  ## 8. Clean Environment Testing

  **Environment Validation:**
  - Verify code works in clean virtual environment
  - Test installation from requirements
  - Ensure no hidden dependencies
  - Validate cross-platform compatibility if needed

  ## 9. Final Commit and Push

  **Commit Execution:**
  - Stage appropriate files for commit
  - Execute git commit with validated message
  - Generate commit hash and metadata
  - Verify commit was successful

  {% if push %}
  **Push Process:**
  - Push changes to remote repository
  - Verify push was successful
  - Check if any conflicts arose
  - Confirm remote branch is updated
  {% endif %}

  ## 10. Post-Commit Validation

  **Repository State Check:**
  - Verify working directory is clean
  - Confirm all intended changes were committed
  - Check that no unintended files were included
  - Validate git history integrity

  **Recommendations Generation:**
  - Suggest improvements for future commits
  - Identify patterns that could be automated
  - Recommend workflow optimizations
  - Note any technical debt created or resolved

  ## Quality Gates

  Before proceeding with commit, ensure ALL of the following pass:
  - ✅ All linting checks pass
  - ✅ All tests pass with 100% coverage for new code
  - ✅ Type hints are present and valid
  - ✅ Documentation is complete and accurate
  - ✅ Commit message follows conventions
  - ✅ No security vulnerabilities detected
  - ✅ Dependencies are up to date
  - ✅ Code follows project patterns

  {% if force_checks %}
  **FORCE CHECKS MODE**: Running all validation checks regardless of initial status.
  {% endif %}

  If any quality gate fails, provide detailed remediation steps before proceeding with the commit.

  Begin the comprehensive code validation and commit process.